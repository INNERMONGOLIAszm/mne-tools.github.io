

.. _sphx_glr_auto_examples_inverse_plot_make_inverse_operator.py:


===============================================================
Assemble inverse operator and compute MNE-dSPM inverse solution
===============================================================

Assemble M/EEG, MEG, and EEG inverse operators and compute dSPM
inverse solution on MNE evoked dataset and stores the solution
in stc files for visualisation.



.. code-block:: python

    # Author: Alexandre Gramfort <alexandre.gramfort@telecom-paristech.fr>
    #
    # License: BSD (3-clause)

    import matplotlib.pyplot as plt

    import mne
    from mne.datasets import sample
    from mne.minimum_norm import (make_inverse_operator, apply_inverse,
                                  write_inverse_operator)

    print(__doc__)

    data_path = sample.data_path()
    fname_fwd_meeg = data_path + '/MEG/sample/sample_audvis-meg-eeg-oct-6-fwd.fif'
    fname_fwd_eeg = data_path + '/MEG/sample/sample_audvis-eeg-oct-6-fwd.fif'
    fname_cov = data_path + '/MEG/sample/sample_audvis-shrunk-cov.fif'
    fname_evoked = data_path + '/MEG/sample/sample_audvis-ave.fif'

    snr = 3.0
    lambda2 = 1.0 / snr ** 2

    # Load data
    evoked = mne.read_evokeds(fname_evoked, condition=0, baseline=(None, 0))
    forward_meeg = mne.read_forward_solution(fname_fwd_meeg, surf_ori=True)
    noise_cov = mne.read_cov(fname_cov)

    # Restrict forward solution as necessary for MEG
    forward_meg = mne.pick_types_forward(forward_meeg, meg=True, eeg=False)
    # Alternatively, you can just load a forward solution that is restricted
    forward_eeg = mne.read_forward_solution(fname_fwd_eeg, surf_ori=True)

    # make an M/EEG, MEG-only, and EEG-only inverse operators
    info = evoked.info
    inverse_operator_meeg = make_inverse_operator(info, forward_meeg, noise_cov,
                                                  loose=0.2, depth=0.8)
    inverse_operator_meg = make_inverse_operator(info, forward_meg, noise_cov,
                                                 loose=0.2, depth=0.8)
    inverse_operator_eeg = make_inverse_operator(info, forward_eeg, noise_cov,
                                                 loose=0.2, depth=0.8)

    write_inverse_operator('sample_audvis-meeg-oct-6-inv.fif',
                           inverse_operator_meeg)
    write_inverse_operator('sample_audvis-meg-oct-6-inv.fif',
                           inverse_operator_meg)
    write_inverse_operator('sample_audvis-eeg-oct-6-inv.fif',
                           inverse_operator_eeg)

    # Compute inverse solution
    stcs = dict()
    stcs['meeg'] = apply_inverse(evoked, inverse_operator_meeg, lambda2, "dSPM",
                                 pick_ori=None)
    stcs['meg'] = apply_inverse(evoked, inverse_operator_meg, lambda2, "dSPM",
                                pick_ori=None)
    stcs['eeg'] = apply_inverse(evoked, inverse_operator_eeg, lambda2, "dSPM",
                                pick_ori=None)

    # Save result in stc files
    names = ['meeg', 'meg', 'eeg']
    for name in names:
        stcs[name].save('mne_dSPM_inverse-%s' % name)





.. rst-class:: sphx-glr-script-out

 Out::

    Reading /home/ubuntu/mne_data/MNE-sample-data/MEG/sample/sample_audvis-ave.fif ...
        Read a total of 4 projection items:
            PCA-v1 (1 x 102) active
            PCA-v2 (1 x 102) active
            PCA-v3 (1 x 102) active
            Average EEG reference (1 x 60) active
        Found the data of interest:
            t =    -199.80 ...     499.49 ms (Left Auditory)
            0 CTF compensation matrices available
            nave = 55 - aspect type = 100
    Projections have already been applied. Setting proj attribute to True.
    Applying baseline correction (mode: mean)
    Reading forward solution from /home/ubuntu/mne_data/MNE-sample-data/MEG/sample/sample_audvis-meg-eeg-oct-6-fwd.fif...
        Reading a source space...
        Computing patch statistics...
        Patch information added...
        Distance information added...
        [done]
        Reading a source space...
        Computing patch statistics...
        Patch information added...
        Distance information added...
        [done]
        2 source spaces read
        Desired named matrix (kind = 3523) not available
        Read MEG forward solution (7498 sources, 306 channels, free orientations)
        Desired named matrix (kind = 3523) not available
        Read EEG forward solution (7498 sources, 60 channels, free orientations)
        MEG and EEG forward solutions combined
        Source spaces transformed to the forward solution coordinate frame
        Converting to surface-based source orientations...
        Average patch normals will be employed in the rotation to the local surface coordinates....
    [done]
        365 x 365 full covariance (kind = 1) found.
        Read a total of 4 projection items:
            PCA-v1 (1 x 102) active
            PCA-v2 (1 x 102) active
            PCA-v3 (1 x 102) active
            Average EEG reference (1 x 59) active
        306 out of 366 channels remain after picking
    Reading forward solution from /home/ubuntu/mne_data/MNE-sample-data/MEG/sample/sample_audvis-eeg-oct-6-fwd.fif...
        Reading a source space...
        Computing patch statistics...
        Patch information added...
        Distance information added...
        [done]
        Reading a source space...
        Computing patch statistics...
        Patch information added...
        Distance information added...
        [done]
        2 source spaces read
        Desired named matrix (kind = 3523) not available
        Read EEG forward solution (7498 sources, 60 channels, free orientations)
        Source spaces transformed to the forward solution coordinate frame
        Converting to surface-based source orientations...
        Average patch normals will be employed in the rotation to the local surface coordinates....
    [done]
    info["bads"] and noise_cov["bads"] do not match, excluding bad channels from both
    Computing inverse operator with 364 channels.
        Created an SSP operator (subspace dimension = 4)
    estimated rank (mag + grad): 302
    Setting small MEG eigenvalues to zero.
    Not doing PCA for MEG.
    estimated rank (eeg): 58
    Setting small EEG eigenvalues to zero.
    Not doing PCA for EEG.
    Total rank is 360
    Creating the depth weighting matrix...
        203 planar channels
        limit = 7262/7498 = 10.020865
        scale = 2.58122e-08 exp = 0.8
    Computing inverse operator with 364 channels.
    Creating the source covariance matrix
    Applying loose dipole orientations. Loose value of 0.2.
    Whitening the forward solution.
    Adjusting source covariance matrix.
    Computing SVD of whitened and weighted lead field matrix.
        largest singular value = 5.62526
        scaling factor to adjust the trace = 1.25951e+19
    info["bads"] and noise_cov["bads"] do not match, excluding bad channels from both
    Computing inverse operator with 305 channels.
        Created an SSP operator (subspace dimension = 3)
    estimated rank (mag + grad): 302
    Setting small MEG eigenvalues to zero.
    Not doing PCA for MEG.
    Total rank is 302
    Creating the depth weighting matrix...
        203 planar channels
        limit = 7262/7498 = 10.020865
        scale = 2.58122e-08 exp = 0.8
    Computing inverse operator with 305 channels.
    Creating the source covariance matrix
    Applying loose dipole orientations. Loose value of 0.2.
    Whitening the forward solution.
    Adjusting source covariance matrix.
    Computing SVD of whitened and weighted lead field matrix.
        largest singular value = 4.50235
        scaling factor to adjust the trace = 7.0775e+18
    info["bads"] and noise_cov["bads"] do not match, excluding bad channels from both
    Computing inverse operator with 59 channels.
        Created an SSP operator (subspace dimension = 1)
    estimated rank (mag + grad): 58
    Setting small EEG eigenvalues to zero.
    Not doing PCA for EEG.
    Total rank is 58
    Creating the depth weighting matrix...
        59 EEG channels
        limit = 7499/7498 = 2.118742
        scale = 155292 exp = 0.8
    Computing inverse operator with 59 channels.
    Creating the source covariance matrix
    Applying loose dipole orientations. Loose value of 0.2.
    Whitening the forward solution.
    Adjusting source covariance matrix.
    Computing SVD of whitened and weighted lead field matrix.
        largest singular value = 2.83329
        scaling factor to adjust the trace = 3.50874e+19
    Write inverse operator decomposition in sample_audvis-meeg-oct-6-inv.fif...
        Write a source space...
        [done]
        Write a source space...
        [done]
        2 source spaces written
        Writing inverse operator info...
        Writing noise covariance matrix.
        Writing source covariance matrix.
        Writing orientation priors.
        [done]
    Write inverse operator decomposition in sample_audvis-meg-oct-6-inv.fif...
        Write a source space...
        [done]
        Write a source space...
        [done]
        2 source spaces written
        Writing inverse operator info...
        Writing noise covariance matrix.
        Writing source covariance matrix.
        Writing orientation priors.
        [done]
    Write inverse operator decomposition in sample_audvis-eeg-oct-6-inv.fif...
        Write a source space...
        [done]
        Write a source space...
        [done]
        2 source spaces written
        Writing inverse operator info...
        Writing noise covariance matrix.
        Writing source covariance matrix.
        Writing orientation priors.
        [done]
    Preparing the inverse operator for use...
        Scaled noise and source covariance from nave = 1 to nave = 55
        Created the regularized inverter
        Created an SSP operator (subspace dimension = 4)
        Created the whitener using a full noise covariance matrix (4 small eigenvalues omitted)
        Computing noise-normalization factors (dSPM)...
    [done]
    Picked 364 channels from the data
    Computing inverse...
    (eigenleads need to be weighted)...
    combining the current components...
    (dSPM)...
    [done]
    Preparing the inverse operator for use...
        Scaled noise and source covariance from nave = 1 to nave = 55
        Created the regularized inverter
        Created an SSP operator (subspace dimension = 3)
        Created the whitener using a full noise covariance matrix (3 small eigenvalues omitted)
        Computing noise-normalization factors (dSPM)...
    [done]
    Picked 305 channels from the data
    Computing inverse...
    (eigenleads need to be weighted)...
    combining the current components...
    (dSPM)...
    [done]
    Preparing the inverse operator for use...
        Scaled noise and source covariance from nave = 1 to nave = 55
        Created the regularized inverter
        Created an SSP operator (subspace dimension = 1)
        Created the whitener using a full noise covariance matrix (1 small eigenvalues omitted)
        Computing noise-normalization factors (dSPM)...
    [done]
    Picked 59 channels from the data
    Computing inverse...
    (eigenleads need to be weighted)...
    combining the current components...
    (dSPM)...
    [done]
    Writing STC to disk...
    [done]
    Writing STC to disk...
    [done]
    Writing STC to disk...
    [done]


View activation time-series


.. code-block:: python

    plt.close('all')
    plt.figure(figsize=(8, 6))
    for ii in range(len(stcs)):
        name = names[ii]
        stc = stcs[name]
        plt.subplot(len(stcs), 1, ii + 1)
        plt.plot(1e3 * stc.times, stc.data[::150, :].T)
        plt.ylabel('%s\ndSPM value' % str.upper(name))
    plt.xlabel('time (ms)')
    plt.show()



.. image:: /auto_examples/inverse/images/sphx_glr_plot_make_inverse_operator_001.png
    :align: center




**Total running time of the script:**
(0 minutes 15.234 seconds)



.. container:: sphx-glr-download

    **Download Python source code:** :download:`plot_make_inverse_operator.py <plot_make_inverse_operator.py>`


.. container:: sphx-glr-download

    **Download IPython notebook:** :download:`plot_make_inverse_operator.ipynb <plot_make_inverse_operator.ipynb>`
